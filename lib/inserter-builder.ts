export interface TableClass {
    filename: string;
    fullPath: string;
    tableName: string;
    className: string;
}
export class InserterBuilder {
    private replaceAll(text:string, search:string, replacement:string):string{
        return text.replace(new RegExp(search, 'g'), replacement);
    }

    private merge<T>(item:T, text:string){
        for (var key in item) {
            let replacement:any = item[key];
            text = this.replaceAll(text,"{{"+key+"}}",replacement);
        }
        return text;
    }

    private getTemplate():string{
        return `/**
 * Autogenerated, do not modify
 */
import Database from "./../database";
{{import}}

export default class Inserter {
    private knex = Database.getKnexInstance();
    async insert<T>(tableName:string, data:T) {
        let q =  this.knex(tableName).insert(data);
        try {
            return await this.knex(tableName).insert(data);
        } catch (error) {
            console.log(q.toString());            
        }
    }    

    async batchInsert<T>(tableName:string, arr:T[]) {
		let chunkSize = 1000;
		await this.knex.batchInsert(tableName, arr, chunkSize);
    }

{{insert}}
}`;
        // return readFileSync("./../app_data/inserter-template.txt", "utf8");
    }

    renderInserter(tables:TableClass[]):string{
        let template =this.getTemplate();
        let inserters = tables.map(t=>this.renderRow(t)).join("\n\n");
        inserters += "\n\n";
        inserters += tables.map(t=>this.renderBatchInsertRow(t)).join("\n\n");        

        template = this.merge({insert:inserters}, template);        

        let imports = tables.map(t=>this.renderImportRow(t)).join("\n");
        template = this.merge({import:imports},template);        
        
        return template;
    }

    private renderImportRow(table:TableClass):string {
        table = JSON.parse(JSON.stringify(table));
        table.filename = table.filename.replace(".ts","");
        let template = 'import {{{className}}} from "./{{filename}}"';
        return this.merge(table,template);
    }

    private renderRow(table:TableClass):string{
        let line1 = "\tasync insert{{className}}(item:{{className}}):Promise<{{className}}>{ \n";
        let line2 = '\t\treturn await this.insert("{{tableName}}", item); \n';
        let line3 = "\t}";
        let row = line1+line2+line3;
        return this.merge(table,row);
    }

    private renderBatchInsertRow(table:TableClass):string{
        let line1 = "\tasync batchInsert{{className}}(items:{{className}}[]):Promise<void>{ \n";
        let line2 = '\t\tawait this.batchInsert("{{tableName}}", items); \n';
        let line3 = "\t}";
        let row = line1+line2+line3;
        return this.merge(table,row);
    }
}